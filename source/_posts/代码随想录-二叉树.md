---
title: 代码随想录-二叉树
date: 2024-1-17
index_img: "/img/bg/xt4.png"
tags: [C++]
categories: 
   -[刷题]
---
二叉树
<!-- more -->

# 二叉树的递归遍历（⭐⭐⭐）

**写递归函数的思考逻辑**：（⭐⭐⭐）
1. 确定递归函数的参数和返回值
2. 确定终止条件
3. 确定单层递归的逻辑

前序遍历：
```C++
void traversal(TreeNode* cur, vector<int>& res){
    if(cur==nullptr) return;
    res.push_back(cur->val);  // 中
    traversal(cur->left, res);  // 左
    traversal(cur->right, res);  // 右
}
```

中序遍历：
```C++
void traversal(TreeNode* cur, vector<int>& res){
    if(cur==nullptr) return;
    traversal(cur->left, res);  // 左
    res.push_back(cur->val);  // 中
    traversal(cur->right, res);  // 右
}
```

后序遍历：
```C++
void traversal(TreeNode* cur, vector<int>& res){
    if(cur==nullptr) return;
    traversal(cur->left, res);  // 左
    traversal(cur->right, res);  // 右
    res.push_back(cur->val);  // 中
}
```

# 二叉树的迭代遍历（非递归）（⭐⭐⭐）

前序遍历：
```C++
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> stack;
    if(root==nullptr){
        return res;
    }
    stack.push(root);
    while(!stack.empty()){
        TreeNode* temp=stack.top();
        res.push_back(temp->val);
        stack.pop();
        // 先让右孩子入栈再让左孩子入栈，因为栈是先进后出
        if(temp->right!=nullptr){  // 右孩子不为空，入栈
            stack.push(temp->right);
        }
        if(temp->left!=nullptr){
            stack.push(temp->left);  // 左孩子不为空，入栈
        }
    }
    return res;
}
```

中序遍历：（⭐⭐⭐）
```C++
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    if(root==nullptr){
        return res;
    }
    stack<TreeNode*> stack;
    TreeNode* cur=root;
    while(cur!=nullptr||!stack.empty()){
        if(cur!=nullptr){
            stack.push(cur);
            cur=cur->left;  // 左
        }else{
            cur = stack.top();
            res.push_back(cur->val);  // 中
            stack.pop();
            cur=cur->right;  // 右
        }
    }
    return res;
}
```

后序遍历：
后序遍历的非递归算法有些技巧，不需要模拟后序遍历的递归栈；前序遍历顺序是 **中左右**，后序遍历顺序是 **左右中**，因此可以使用前序遍历顺序为**中右左**得到数组，再reverse数组即可。
```C++
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> res;
    if(root==nullptr){
        return res;
    }
    stack<TreeNode*> stack;
    stack.push(root);
    while(!stack.empty()){
        TreeNode* tempNode=stack.top();
        stack.pop();
        res.push_back(tempNode->val);
        if(tempNode->left!=nullptr){
            stack.push(tempNode->left);
        }
        if(tempNode->right!=nullptr){
            stack.push(tempNode->right);
        }
    }
    reverse(res.begin(),res.end());
    return res;
}
```

# 二叉树的层序遍历（⭐⭐⭐）

## 二叉树的层序遍历（⭐⭐）

[LeetCode.102](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

核心代码：
```C++
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> res;
    if(root==nullptr){
        return res;
    }
    queue<TreeNode*> queue;
    queue.push(root);
    while(!queue.empty()){
        int size=queue.size();  // 记录当前队列中元素个数，就是当前层的元素个数
        vector<int> secVec;
        for(int i=0;i<size;i++){
            TreeNode* tempNode=queue.front();
            queue.pop();
            secVec.push_back(tempNode->val);
            if(tempNode->left!=nullptr){
                queue.push(tempNode->left);
            }
            if(tempNode->right!=nullptr){
                queue.push(tempNode->right);
            }
        }
        res.push_back(secVec);
    }
    return res;
}
```

## 二叉树的层序遍历Ⅱ

[LeetCode.107](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/)

和上一题一样，最后翻转结果数组即可；

核心代码：
```C++
vector<vector<int>> levelOrderBottom(TreeNode* root) {
    vector<vector<int>> res;
    if(root==nullptr){
        return res;
    }
    queue<TreeNode*> queue;
    queue.push(root);
    while(!queue.empty()){
        int size=queue.size();
        vector<int> secVec;
        for(int i=0;i<size;i++){
            TreeNode* tempNode=queue.front();
            secVec.push_back(tempNode->val);
            queue.pop();
            if(tempNode->left!=nullptr){
                queue.push(tempNode->left);
            }
            if(tempNode->right!=nullptr){
                queue.push(tempNode->right);
            }
        }
        res.push_back(secVec);
    }
    reverse(res.begin(),res.end());
    return res;
}
```